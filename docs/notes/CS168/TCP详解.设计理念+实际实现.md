# TCP详解.设计理念+实际实现

## 传输层协议设计理念

对于应用层, 传输层要将数据的传输抽象成一个端到端的连接, 应用层不考虑数据是怎么被传输的, 只直到与服务器建立连接后, 发送的数据一定会完好的, 顺序不变的到达服务器. 以及对于多个应用, 应该可以同时建立网络连接

有这么几个问题:1) 保证数据发送一定送到且没有损坏. 2) 保证数据发送的顺序不变 3) 对于机器上的多个应用允许同时多个连接.(多路复用). 4. congestion control. 避免传输的包太多,在网络中阻塞 5.flow control 依然是包一次传输太多, 接收者缓冲区不够.

此外,在解决以上问题的同时, 要做到尽量快的速度, 以及占用尽量少的带宽. 另外也有对速度要求很高但是可靠性不高的需求.

## TCP协议

### single packet reliability protocol

If you are the sender: Send the packet, and set a timer. If no ack arrives before the timer goes off, re-send the packet and reset the timer. Stop and cancel the timer when the ack arrives.

If you are the recipient: If you receive the uncorrupted packet, send an ack. (You might send multiple acks if you receive the packet multiple times.)

The core ideas in this example will apply to later protocols as well: checksums (for corruption), acknowledgements, re-sending packets, and timeouts.

Note that this protocol guarantees at-least-once delivery, since duplicates may exist.

# 可靠传输多个数据包

## 一、基本问题与解决方案

### 1. Stop-and-Wait协议(停止等待)

- **方法**: 发送包i后,等待ACK才发送包i+1
- **优点**: 简单可靠
- **缺点**: 太慢!每个包至少需要1个RTT

### 2. 改进:并行发送

- **问题**:
    - 一次发一个太慢
    - 一次全发会压垮网络
- **解决**: **窗口机制** - 限制同时在网络中(in-flight)的包数量为W

---

## 二、窗口大小(W)的确定

### **核心公式**

```
W × 包大小 = RTT × 瓶颈带宽(B)

```

### 三个目标及对应窗口:

### 1️⃣ **充分利用带宽(填满管道)**

```
W = RTT × B / 包大小

```

- **例子**: RTT=1秒, B=8Mbps, 包大小=100字节
    - W = 1秒 × 8Mbps / 100字节 = 10,000个包
- **目标**: 让发送方在整个RTT期间持续发送,不闲置

### 2️⃣ **流量控制(不压垮接收方)**

```
W ≤ 接收方广告窗口(Advertised Window)

```

- **原因**: 接收方需要缓存乱序到达的包,内存有限
- **机制**: 接收方在ACK中告知剩余缓冲区大小

### 3️⃣ **拥塞控制(不压垮网络)**

```
W ≤ 拥塞窗口(Congestion Window, cwnd)

```

- **原因**: 多个连接共享带宽,需要公平分配
- **机制**: 通过拥塞控制算法动态计算

### **最终窗口大小**

```
W = min(拥塞窗口, 接收方广告窗口)

```

> 注: 实践中忽略"充分利用带宽"这个值,因为难以准确获知,且总是≥拥塞窗口
> 

---

## 三、更智能的确认机制(ACK)

### 对比三种ACK策略:

| 策略 | 内容 | 优点 | 缺点 |
| --- | --- | --- | --- |
| **单独ACK** | 每个ACK对应一个包 | 清晰明确 | ACK丢失会导致不必要的重传 |
| **完全信息ACK** | 列出所有已收到的包 | 信息完整,容错性好 | ACK可能变得很长 |
| **累积ACK** | 只报告"收到所有≤N的包" | 固定长度,不会膨胀 | 信息模糊,不知道哪些乱序包已到达 |

### **TCP实际使用: 累积ACK**

```
示例:
- 收到包1,2,4,5
- ACK显示: "所有≤2的包都收到了"
- 不包含4,5的信息(因为3缺失,不连续)

```

---

## 四、提前检测丢包(快速重传)

### 不等超时,提前检测丢包:

**规则**: 如果在缺失包之后收到K个后续包的ACK,则认为该包丢失

### 在不同ACK机制下的表现:

### 1. **单独ACK**: 清晰

```
缺包5,收到ACK: 6, 7, 8
→ 3个后续ACK到达,判定包5丢失

```

### 2. **完全信息ACK**: 清晰

```
ACK显示: "≤4", "≤4,plus 6", "≤4,plus 6,7", "≤4,plus 6,7,8"
→ 明确看到3个后续包,判定包5丢失

```

### 3. **累积ACK**: 模糊但可行

```
ACK显示: "≤4", "≤4", "≤4", "≤4" (重复ACK)
→ 收到3个重复ACK(共4个"≤4"),判定包5丢失

```

### **问题**: 累积ACK在多包丢失时模糊

```
场景: 包3和5都丢失,窗口W=6, K=3
- 收到重复ACK后知道有包丢失
- 但不确定是哪些包丢失
- 发送方需要推测应该重传哪个包

```

---

## 五、关键要点

1. **窗口机制是核心**: 平衡速度与网络负载
2. **窗口大小由三个因素决定**: 带宽、接收方能力、网络拥塞
3. **累积ACK是工程权衡**: 简单高效,但牺牲了部分信息精确度
4. **快速重传**: 比超时重传快得多(微秒级 vs 秒级)
5. **多包丢失时的模糊性**: 累积ACK的固有缺陷,但整体效益仍优于单独ACK

# TCP实现

---

## 一、从概念到实现:字节流抽象

### 1.1 核心转变

- **之前**:概念层面讨论"发送packet"
- **现在**:应用层提供的是**连续字节流**,不是预制的packet
- **实现挑战**:需要将所有TCP概念(序列号、窗口大小等)从"packet视角"转换为"字节视角"

### 1.2 TCP Segment的产生

**定义**:TCP segment是TCP实现层面的数据单元

**形成过程**:

1. 发送方的TCP实现从字节流中**逐字节收集数据**
2. 将字节放入一个TCP segment中
3. 当segment达到**最大segment大小(MSS)**时,发送该segment
4. 开始填充新的segment

**处理不满载的情况**:

- **问题**:如果发送数据量小于MSS,segment会一直等待
- **解决**:每次开始填充新segment时启动**计时器**
- **机制**:计时器到期时,即使segment未满也发送

### 1.3 数据封装流程

`应用层字节流
    ↓
TCP实现收集字节 → 形成TCP segment
    ↓
添加TCP header(序列号、端口号等)
    ↓
传递给IP层
    ↓
添加IP header
    ↓
通过网络发送 (形成TCP/IP packet)`

**术语**:

- **TCP/IP packet** = IP header + TCP header + TCP segment data
- 等价于:payload是TCP数据的IP packet

### 1.4 MSS的计算

`MSS = MTU - IP header大小 - TCP header大小
典型值:
1460字节 = 1500字节 - 20字节 - 20字节`

**原理**:

- MTU限制了IP packet的总大小
- TCP segment必须为IP/TCP header留出空间
- MSS是TCP能承载的**纯数据**大小

---

## 二、序列号机制(Sequence Numbers)

### 2.1 字节编号系统

- **不是给segment编号**,而是给字节流中的**每个字节编号**
- 每个segment的序列号 = 该segment中**第一个字节**的编号
- 接收方通过序列号重组segment

### 2.2 初始序列号(ISN)

**机制**:

- 每个字节流从一个随机选择的ISN开始
- 第一个字节编号 = ISN+1
- 第二个字节编号 = ISN+2
- 依此类推

**示例**:

`ISN = 50
字节编号:51, 52, 53, 54...
某segment包含字节140-219:
  - 序列号 = 140
  - 包含80个字节`

### 2.3 确认号(Acknowledgement Number)

**含义**:

- "我已收到所有字节,直到但**不包括**这个编号"
- 等价于:"我期待的**下一个字节**编号"
- 使用**累积确认模型**

**数学关系**:

`假设packet:
- 首字节序列号 = X
- 包含B个字节
- 字节范围:X, X+1, X+2, ..., X+B-1

如果正常接收:
- 确认号 = X+B (下一个期待的字节)

如果丢失:
- 确认号 = 某个小于X+B的数字(累积确认特性)`

### 2.4 为什么ISN是随机的

**历史原因**(已过时):

- 防止连接崩溃后序列号混淆
- 场景:sender崩溃重启,如果都从0开始,receiver无法区分新旧连接

**现代原因**(主要):

- **安全性** - 防止序列号预测攻击
- 如果ISN可预测,攻击者可以:
    - 推断出正确的序列号
    - 发送伪造的packet,看起来像是来自合法发送方
- 随机ISN使攻击者难以猜测序列号

## 三、TCP状态管理

### 3.1 状态存储位置

- 状态维护在**终端主机**上实现TCP的地方
- **不在网络中**存储状态

### 3.2 发送方需要维护的状态

1. **未确认的字节**:哪些字节已发送但未被确认
2. **各种计时器**:
    - 何时发送未满载的segment
    - 何时重传字节

### 3.3 接收方需要维护的状态

- **乱序字节**:已收到但还不能交付给应用层的字节

### 3.4 连接的概念

**因为需要维护状态**:

- 每个字节流称为**连接(connection)**
- TCP是**面向连接的协议**(connection-oriented)

**与Layer 3的区别**:

- Layer 3:每个packet可独立考虑
- TCP:双方必须先建立连接并初始化状态,才能发送数据

**连接管理**:

- 需要机制来建立连接
- 需要机制来拆除连接(释放两端的状态内存)

## 五、TCP握手(Three-way Handshake)

### 5.1 握手的目的

- TCP是面向连接的,连接必须显式创建
- 字节流从随机选择的ISN开始
- 全双工连接有两条字节流,需要**两个ISN**(每个方向一个)
- **握手目标**:双方协商两个方向的ISN

### 5.2 三次握手流程

**第一步:SYN**

- A → B发送SYN消息
- 包含A的ISN(在序列号字段中)
- 含义:"A→B方向的数据将从这个ISN开始计数"

**第二步:SYN-ACK**

- B → A发送SYN-ACK消息
- 序列号字段:包含B的ISN(B→A方向的数据从此开始)
- 确认号字段:确认收到A的ISN(值为A的ISN+1)

**第三步:ACK**

- A → B发送ACK消息
- 确认号字段:确认收到B的ISN(值为B的ISN+1)

## 如果没有建立连接就发送数据包?

服务器发现包来自未建立连接的IP和端口, 丢弃数据包, 并发送RST.

正常客户端会发现RST, 连接断开. 

但是恶意程序如果一直发送包, 不管RST, 会对服务器造成性能上的影响(需要处理解析包以及发送RST.占用CPU,以及网络带宽)

这也是DDos攻击的原理(其通常用SYN Flood).

## 六、结束连接

### 6.1 正常结束:FIN packet

**机制**:

1. 一方发送完数据后,发送**FIN packet**
    - 含义:"我不会再发送数据,但继续接收你的数据"
    - 此时连接进入**半关闭状态**
    - 这个FIN会像普通packet一样被ACK
2. 另一方最终也发送完数据,发送自己的FIN packet
3. 当第二个FIN被ACK后,连接完全关闭

### 6.2 强制结束:RST packet

**使用场景**:

- 需要突然终止连接
- 不需要对方同意
- 单方面结束连接

**机制**:

- 发送**RST packet**
- 含义:"我不会再发送或接收任何数据"
- **不需要被ACK**
- 发送RST后立即拆除连接

**典型使用情况**:

1. 主机遇到错误,无法继续收发packet
2. 任何在传输中的数据都会丢失(如果主机崩溃并丢失状态)
3. 如果对方继续发送数据,会重复发送RST packet试图终止连接

**安全问题**:

- 攻击者可以伪造并注入RST packet
- 导致整个连接被终止
- 这是一种审查连接的攻击手段

## 七、滑动窗口(Sliding Window)

### 8.1 从packet窗口到字节窗口

**之前(packet视角)**:

- 窗口 = 任意时刻可以在传输中的packet数量

**现在(字节视角)**:

- 滑动窗口 = 任意时刻可以在传输中的**最大连续字节数**

### 8.2 连续性限制

**关键差异**:

- Packet窗口:允许非连续packet在传输中(如packet 5,7,8)
- 字节窗口:**必须连续**,不能有间隙
- 这个限制形成了字节流中的一个"窗口(范围)"

### 8.3 窗口的边界

**左边界**:

- 第一个**未确认的字节**(由接收方的ACK号确定)

**右边界**:

- 从左边界开始,接下来的W个字节
- W = 窗口大小

**可发送范围**:

- 左边界到右边界之间的字节可以在传输中

**可视化**:

`字节流: ... | 已确认 | ←----- 窗口(W字节) -----→ | 不能发送 | ...
                    ↑                          ↑
                  左边界                     右边界
              (第一个未确认字节)`

### 8.4 窗口移动规则

**重要限制**:

- 即使窗口内的某些中间字节已被确认
- **仍然不能**发送超出右边界的字节
- 只有当窗口**向右滑动**时才能发送更多字节

**窗口何时滑动**:

- 当ACK号增加时(左边界的字节被确认)
- 窗口整体向右移动

**示例**:

`初始: [100-199] 在传输中,窗口大小=100
      左边界=100, 右边界=199

收到ACK=150:
      窗口滑动: [150-249]
      左边界=150, 右边界=249
      现在可以发送字节200-249`

### 8.5 窗口大小的决定因素

**流量控制**:

- 窗口大小 = 接收方**通告的窗口**
- 接收方根据**接收缓冲区可用空间**决定通告窗口

**拥塞控制**:

- 窗口大小还受拥塞控制算法限制
- 两者取较小值

## 八、检测丢失和重传数据

### 9.1 两个触发条件

**只需满足一个**(不是两个都要)就触发重传:

### 9.2 触发条件1:超时(Timer)

**Packet视角(之前)**:

- 每个packet有一个计时器
- 计时器到期且未被ACK → 重传该packet

**字节视角(现在)**:

- **只有一个计时器**,对应第一个未确认字节(窗口左边界)
- 计时器到期 → 重传**最左边的未确认segment**

**计时器机制**:

- 计时器长度基于RTT
- RTT通过测量"发送数据→收到ACK"的时间估算
- 每次收到新ACK(窗口改变)时,**重置计时器**

### 9.3 触发条件2:重复ACK

**Packet视角(之前)**:

- 使用累积ACK
- 收到K个重复ACK(通常K=3)时重传packet
- 重复ACK表示后续packet被确认了

**字节视角(现在)**:

- 收到K个重复ACK时
- 重传**最左边的未确认segment**

**原理**:

- 重复ACK意味着:
    - 接收方收到了后续的数据
    - 但某个早期数据仍然缺失
    - 该数据很可能已丢失

---

## 九、TCP Header结构

### 10.1 端口号(各16位)

- **源端口**(Source Port):16位
- **目的端口**(Destination Port):16位

### 10.2 序列号和确认号(各32位)

- **序列号**(Sequence Number):32位
    - 该packet中第一个字节的字节偏移量
- **确认号**(Acknowledgement Number):32位
    - 已收到的最高连续序列号+1

### 10.3 校验和(Checksum)

- 覆盖**整个数据**(不仅是header)
- 用于检测数据损坏

### 10.4 通告窗口(Advertised Window)

- 用于支持流量控制和拥塞控制
- 接收方告诉发送方自己的接收窗口大小

### 10.5 Header长度(Header Length)

- 指定TCP header中**4字节字(word)**的数量
- 假设没有额外选项,长度=5(5×4=20字节)

### 10.6 标志位(Flags)

一系列可以设置为0或1的位:

**SYN(Synchronize)标志**:

- 当主机发送ISN时开启
- 通常只在握手的前两个消息中启用

**ACK(Acknowledge)标志**:

- 当确认号有效且被使用时开启
- 如果要发送数据但没有需要ACK的数据:
    - 可以关闭此标志
    - 告诉对方忽略ACK号字段

**FIN(Finish)标志**:

- 请求关闭连接

**RST(Reset)标志**:

- 强制重置连接

### 10.7 保留位(Reserved Bits)

- Header长度后有6个保留位
- 总是设置为0
- 可以忽略

### 10.8 紧急指针(Urgent Pointer)

- 可以标记某些字节为紧急
- 告诉接收方尽快将这些数据发送给应用层
- 历史遗留字段,现代较少使用

### 10.9 选项(Options)

- TCP header末尾可以附加额外选项(使header变长)
- 示例:**选择性确认(SACK)**
    - 如果想实现完全信息ACK
    - 可以添加SACK选项到header中

**Header结构可视化**:

`0                   16                  31
+-------------------+-------------------+
|   Source Port     | Destination Port  |
+-------------------+-------------------+
|          Sequence Number              |
+---------------------------------------+
|       Acknowledgement Number          |
+-------+-------+-----------------------+
|Header | Rsv   |       Flags           |
|Length |       | |U|A|P|R|S|F|         |
+-------+-------+-----------------------+
|    Window     |      Checksum         |
+---------------------------------------+
| Urgent Pointer|      Options...       |
+---------------------------------------+`